PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE "schema_migrations" ("version" varchar(255) NOT NULL);
INSERT INTO "schema_migrations" VALUES('20130122042648');
INSERT INTO "schema_migrations" VALUES('20130122045842');
INSERT INTO "schema_migrations" VALUES('20130815025652');
INSERT INTO "schema_migrations" VALUES('20130815032206');
INSERT INTO "schema_migrations" VALUES('20130815032207');
INSERT INTO "schema_migrations" VALUES('20130815184458');
INSERT INTO "schema_migrations" VALUES('20130815200631');
INSERT INTO "schema_migrations" VALUES('20130815213714');
INSERT INTO "schema_migrations" VALUES('20130815214328');
INSERT INTO "schema_migrations" VALUES('20130821184237');
INSERT INTO "schema_migrations" VALUES('20130821191042');
INSERT INTO "schema_migrations" VALUES('20130822071123');
INSERT INTO "schema_migrations" VALUES('20130826182356');
CREATE TABLE flaws (id INTEGER PRIMARY KEY, title varchar(255), description text, classification_id integer, created_at datetime, updated_at datetime, state varchar(255), "recommendation" text, "affects" text, "reference" text, "priority" integer, "progress" integer);
INSERT INTO "flaws" VALUES(1,'@ .../drivers/base/core.c: 1783','<pre><pre>line 1735: new_parent= get_device(new_parent)</pre></pre><br><br>get_device function can return NULL like this:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br><div>
<pre><pre>return dev ? to_dev(kobject_get(&amp;dev-&gt;kobj)) : NULL;
</pre></pre></div><br>This condition is not checked immediately after the statement and&nbsp;new_parent is potentially assigned NULL ( at line 1735) - This is a mistake on its own.<br><br>Developers might be anticipating this condition further in code and a check to existence of new_parent (compare to NULL ) is made which implies that this pointer might be expected to be a NULL<br><br><br>Regardeless of this - line 1780 and 1783 a call is made to&nbsp;device_pm_move_after function passing new_parent which might potentially be NULL in device_pm_move_before(new_parent, dev);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; lines 154,155 and 141,142 directly dereference the NULL pointer<br><br><pre><pre>138 void device_pm_move_before(struct device *deva, struct device *devb)
139{
140 pr_debug("PM: Moving %s:%s before %s:%s\n",
141 deva-&gt;bus ? deva-&gt;bus-&gt;name : "No Bus", dev_name(deva),
142 devb-&gt;bus ? devb-&gt;bus-&gt;name : "No Bus", dev_name(devb));
143 /* Delete deva from dpm_list and reinsert before devb. */
144 list_move_tail(&amp;deva-&gt;power.entry, &amp;devb-&gt;power.entry);
145}</pre></pre><br>Dereferencing a NULL pointer will cause a program to crash.<br><br><br><br><br><br><br><br><br><br>',2,'2013-08-16 15:24:10.998541','2013-08-26 19:05:36.731414','L2','',NULL,NULL,1,100);
INSERT INTO "flaws" VALUES(2,'@ /srvkm/common/buffer_manager.c: 1443,2744','This covers instances where a pointer is dereferenced then subsequently checked against NULL. <br><br><h5>A:</h5>dereference at line <br>&nbsp;&nbsp;&nbsp; 1443: PVRSRV_DEVICE_NODE *psDeviceNode = psBMHeap-&gt;pBMContext-&gt;psDeviceNode;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; |-&gt; with null-check following at line <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 1447: if(psBMHeap)<br><br><br>The development needs to verify that:<br><br><u>Scenario 1.</u> If check is performed because the other code is not trusted (unlikely because it is in cloise proximity to the functionality)- this is the correct behavior. Since dereferencing a NULL pointer will cause a process to crash, checking against NULL before dereferencing is very important.<br><br><u>Scenario 2. </u>If the dereferencing is performed without first Null-checking the pointer this is an issue on dereference unless in cases when the dereference can be safe if the programmer knows it could not be null. If this is the case, then checking against NULL further in code is unnecessary and should be removed as it indicates to others that the pointer could be NULL.<br>As a second possibility, the pointer *might* be NULL, and it can be fixed by moving the NULL check before the dereference at an earlier time.<br><br><h5>B.</h5>Other places the same pattern occurs:<br><br>/srvkm/common/buffer_manager.c: 2744<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (this is likely a FP since this is an ENUM member but leaving for completeness.<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dereference at line <br>2744: pMapping-&gt;hOSMemHandle = 0;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; |-&gt; with null-check at line <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 3024 : if (pMapping &amp;&amp; (pMapping-&gt;CpuVAddr || pMapping-&gt;hOSMemHandle))<br><br><br>',3,'2013-08-16 15:33:45.463137','2013-08-16 15:34:31.383761','L1','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(3,'@ drivers/gpu/pvr/services4/srvkm/common/deviceclass.c: 633','In the Code: <br>OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(PPVRSRV_BC_SRV2BUFFER_KMJTABLE), psBCInfo-&gt;psFuncTable, IMG_NULL);<br><br>parameter is defined in /drivers/gpu/pvr/services4/srvkm/common/deviceclass.c:143 as<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; typedef struct PVRSRV_BC_SRV2BUFFER_KMJTABLE_TAG *PPVRSRV_BC_SRV2BUFFER_KMJTABLE;<br><br>Did you mean to pass <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sizeof(PVRSRV_BC_SRV2BUFFER_KMJTABLE_TAG) to OSFreeMem <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; rather than <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sizeof(PPVRSRV_BC_SRV2BUFFER_KMJTABLE) instead?<br><br>The result may be an incorrect value that may cause unexpected program behaviors. <br><br><i><u>SEC Develpment:</u></i> Please verify.<br><br><br>',4,'2013-08-16 15:37:44.382398','2013-08-28 18:08:40.192759','L1','',NULL,NULL,3,100);
INSERT INTO "flaws" VALUES(4,'@ /srvkm/common/devicemem.c: 1749','At line 1749 we find function PVRSRVWrapExtMemoryKM calling OSAcquirePhysPageAddr which allocates memory that is stored into "hOSWrapMem"<br><br>line 1749 eError = OSAcquirePhysPageAddr(pvPageAlignedCPUVAddr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uPageCount * ui32HostPageSize,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; psIntSysPAddr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hOSWrapMem);<br><br><br><br>Further in code looking in funciton OSAcquirePhysPageAddr<br>line 3568:<br>&nbsp; <br><br>psInfo = kmalloc(sizeof(*psInfo), GFP_KERNEL);<br><br>we see asignment to psInfo, and if we trace further in function OSAcquirePhysPageAddr<br>line 3804 :<br>&nbsp;&nbsp;&nbsp; *phOSWrapMem = (IMG_HANDLE)psInfo;<br><br>we see that psInfo is being cast to phOSWrapMem<br><br>Tracing back out of function OSAcquirePhysPageAddr into PVRSRVWrapExtMemoryKM function at<br>line 1919. Here we see that logic is falling through to error condition (taking false branches lines 1889-1918 ) to return from function :<br>&nbsp;&nbsp;&nbsp; return eError;<br><br>This leaves a variable "hOSWrapMem" going out of scope and therefore leaking the storage it points to.<br><br><br><br><br><br><br><br>',1,'2013-08-16 15:43:16.439859','2013-08-26 19:02:22.987284','L2','',NULL,NULL,1,100);
INSERT INTO "flaws" VALUES(5,'@ /gpu/pvr/services4/srvkm/include/lists.c: 54, 69','2 occurrences (lines 54 and 69 )<br>Example of line 69 has a call to macro<br><br>IMPLEMENT_LIST_FOR_EACH_VA(PVRSRV_DEVICE_NODE)<br><br>This macro resolves (in file lists.h) to:<br><br><br>105 &nbsp;&nbsp;&nbsp; #define IMPLEMENT_LIST_FOR_EACH_VA(TYPE) \<br>106&nbsp;&nbsp;&nbsp; IMG_VOID List_##TYPE##_ForEach_va(TYPE *psHead, IMG_VOID(*pfnCallBack)&nbsp;&nbsp;&nbsp; (TYPE* psNode, va_list va), ...) \<br>107{\<br>108 va_list ap;\<br>109 while(psHead)\<br>110 {\<br>111 va_start(ap, pfnCallBack);\<br>112 pfnCallBack(psHead, ap);\<br>113 psHead = psHead-&gt;psNext;\<br>114 va_end(ap);\<br>115 }\<br>116}<br><br>Let''s note the pfnCallBackfunction and psHeadrepr linked list pointers.<br><br>Tracing steps:<br><br>Step 1:<br>On the 3rd iteration of this loop the code would assign: "psHead" = "psHead-&gt;psNext". Now both point to the same storage.<br><br>Step 2:<br>The function pointer resolves*pfnCallBack&nbsp;to&nbsp;BM_DestroyContextCallBack_AnyVaCb(BM_HEAP *, va_list)".<br>Then BM_DestroyContextCallBack_AnyVaCb&nbsp;frees "psHead".<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; on line 989 by calling OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof(BM_HEAP), psBMHeap, IMG_NULL);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; which calls&nbsp;OSFreeMem_Impl&nbsp;from&nbsp;osfunc.c<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; which calls&nbsp;mm.c<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; which frees the pointer at line 311<br><br>Then the loop may continue with de-reference to&nbsp;psHead&nbsp;(already freed before).<br><br>Development needs to look into this condition.<br><br>Incorrect values may be read from freed memory, causing incorrect computations.<br>You cannot safely use freed memory. Double free defects occur when free() is called more than once with the same memory address argument. Double freeing a pointer can result in memory free list corruption and crashes. Dereferencing a freed pointer is dangerous because the pointer''s value might have been changed to a non-pointer value or a pointer to an arbitrary location.<br>In multi-threaded programs, double frees are especially dangerous because one thread could allocate another''s freed memory, resulting in very difficult to track race-conditions.<br><br>',5,'2013-08-16 15:46:03.500307','2013-08-16 15:46:03.500307','L1','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(6,'@ /srvkm/common/ra.c: 914','In function _FreeBT line <br>&nbsp;&nbsp;&nbsp; 855 : pNeighbour = pBT-&gt;pPrevSegment; <br><br>This&nbsp; operation is assigning: "pNeighbour" = "pBT-&gt;pPrevSegment". Now both point to the same storage.<br>Then on line <br>864: OSFreeMem_Impl(IMG_UINT32, IMG_SIZE_T, IMG_PVOID, IMG_HANDLE) <br>This call rees "pNeighbour" ( via a call to kfree() in files: linux/osfunc.c which is calling subsequently linux/mm.c )<br><br>Then back to function _FreeBT, line <br><br><br>914: &nbsp; if (pBT-&gt;pNextSegment!=IMG_NULL &amp;&amp; pBT-&gt;pNextSegment-&gt;type == btt_span &amp;&amp; pBT-&gt;pPrevSegment!=IMG_NULL &amp;&amp; pBT-&gt;pPrevSegment-&gt;type == btt_span)<br><br>Ads we can see this dereferences&nbsp;freedpointer "pBT-&gt;pPrevSegment".<br><br>Development needs to look into this condition.<br>Incorrect values may be read from freed memory, causing incorrect computations.<br>You cannot safely use freed memory. Double free defects occur when free() is called more than once with the same memory address argument. Double freeing a pointer can result in memory free list corruption and crashes. Dereferencing a freed pointer is dangerous because the pointer''s value might have been changed to a non-pointer value or a pointer to an arbitrary location.<br>In multi-threaded programs, double frees are especially dangerous because one thread could allocate another''s freed memory, resulting in very difficult to track race-conditions.<br><br><br>',5,'2013-08-16 15:49:40.279225','2013-08-16 15:49:40.279225','L1','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(7,'@ .../drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c: 1978,1805','In Function&nbsp;MMU_initialize:<br><br>Starting at line 1774 (OSAllocMem function) the 3rd argument of psMMUContext passed as (IMG_VOID **)&amp;psMMUContextand is set inside the function<br>at line <br><br>149: *ppvCpuVAddr= KMallocWrapper(uiSize, GFP_KERNEL | __GFP_NOWARN);<br><br>The pointer ubsequently returns back to the calling function.<br><br><br>Then we see at line a calls <br>1783: <br>&nbsp;&nbsp;&nbsp; OSMemSet (psMMUContext, 0, sizeof(MMU_CONTEXT)); //from osfunc.c file<br><br>Under preprocessor condition of<br>#if defined(USE_UNOPTIMISED_MEMSET)<br><br>the local *pvDest pinter ( psMMUContext ) is not freed as it does correctly in line 505 if USE_UNOPTIMISED_MEMSET is not used.<br><br>Finally at line 1978 the function&nbsp;MMU_initialize returns potentially leaving&nbsp;psMMUContext memory allocated under certain conditons.<br><br><br>',1,'2013-08-16 15:53:19.893066','2013-08-26 19:47:52.463311','L2','',NULL,NULL,1,100);
INSERT INTO "flaws" VALUES(8,'@ /drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c: 927, 4385','Two instances:<br><br><b>A: function _AllocPageTableMemory:</b><br><br>at line 835 if(psPTInfoList-&gt;PTPageCpuVAddr) pointer comparison to a NULL implies that<br>code at line 832&nbsp; might set psPTInfoList-&gt;PTPageCpuVAddr to NULL.<br><br>832: MakeKernelPageReadOnly(psPTInfoList-&gt;PTPageCpuVAddr); <br><br><br>at line 927 OSMemSet(psPTInfoList-&gt;PTPageCpuVAddr,0, pMMUHeap-&gt;ui32PTSize); is called // from osfunc.c<br>where at line 505 memset(pvDest, (IMG_INT) ui8Value, (size_t) uiSize); is dereferenced without further checks.<br><br><b>B: function MMU_BlFResetPDAlloc:</b><br><br>at line 4318 if(pui8MemBlock) pointer comparison to a NULL implies that code at line <br><br>4303: eError = OSAllocPages(PVRSRV_HAP_WRITECOMBINE | PVRSRV_HAP_KERNEL_ONLY,<br>&nbsp;&nbsp;&nbsp; …<br>(IMG_VOID **)&amp;pui8MemBlock, ... ); <br>is expected to potentially nullify pui8MemBlock pointer.<br>falling through to line 4381 where psDevInfo-&gt;pui32BIFResetPD= (IMG_UINT32 *)pui8MemBlock; is aliased<br>and further passed to an OSMemSet(psDevInfo-&gt;pui32BIFResetPD, 0, SGX_MMU_PAGE_SIZE); allocator in osfunc.c:493 without further checks.<br><br><br>',2,'2013-08-16 15:56:56.543059','2013-08-16 15:56:56.543059','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(9,'@ /drivers/gpu/pvr/services4/srvkm/devices/sgx/mmu.c 1429,1774,2911','Starting with a call to allocator: <br><br>OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP, sizeof (MMU_PT_INFO), "MMU Page Table Info");<br><br>This points to calling function "OSAllocMem_Impl(IMG_UINT32, IMG_SIZE_T, IMG_PVOID *, IMG_HANDLE *)"&nbsp;without checking return value.<br><br>Actually, OSAllocMem_Impl (defined in osfunc.c ) may return&nbsp;PVRSRV_ERROR_OUT_OF_MEMORY&nbsp;condition which would be unaccounted for in this code logic.<br><br>Also, this pattern is inconsistent with other places in code where the return is actually checked:<br>Examples where return value is checked:<br><br>if (OSAllocMem(PVRSRV_OS_PAGEABLE_HEAP,<br>&nbsp;&nbsp;&nbsp; sizeof (BM_MAPPING),<br>&nbsp;&nbsp;&nbsp; (IMG_PVOID *)&amp;pMapping, IMG_NULL,<br>&nbsp;&nbsp;&nbsp; "Buffer Manager Mapping") !=&nbsp;PVRSRV_OK){ ... }<br><br>InstanceA:bridged_pvr_bridge.c:2977<br>InstanceB:bridged_sgx_bridge.c:2278,bridged_sgx_bridge.c:2283<br>InstanceC:buffer_manager.c:2735<br>InstanceD:deviceclass.c:383<br>InstanceE:ra.c:483<br><br><br>',7,'2013-08-16 15:58:59.185587','2013-08-16 15:58:59.185587','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(10,'@ .../drivers/base/dma-buf.c : 273','<span><i>273	struct
sg_table *sg_table = ERR_PTR(-EINVAL);</i><br></span><span><span><br>If
the function returned a handle to an object, the handle may be lost.
In dma_buf_map_attachment: Pointer returned from a function was never
used. <br><br>It is likely that the variable is simply vestigial, but
it is also possible that the unused variable points out a bug. <br></span><br>
</span>

<br>',8,'2013-08-16 16:12:08.383188','2013-08-16 16:12:08.383188','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(11,'@ .../drivers/base/cpu.c: 69','&nbsp;<span><i>69:
devie_create_file(&amp;cpu-&gt;dev, &amp;dev_attr_online);</i><span><br><br><br></span><u>Description
and Scenario:</u></span>
<span><span><br>If
the function returns an error value, the error value may be mistaken
for a normal value.<br>In register_cpu_control: Value returned from a
function is not checked for errors before being used &nbsp;as done in
other parts of code appropriately with the following patterns:<br><br></span><i>error
= device_create_file(...); <br><br>if (error) </i>
</span>
<span><i>	do_something;
</i>
</span>
<span><span><br><br>Since
the logic of device_create_file ultimately calls on </span><i>kzalloc()
</i><span>of
resources deep in the kernel''s sysfs interface it definitely can fail
upon resource starvation or  other faulty conditions.<br>It is
advised to always check the return values from clritical code
sections.<br></span><br>
</span>

<br>',7,'2013-08-16 16:13:36.527131','2013-08-16 16:13:36.527131','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(12,'@ .../dirvers/devfreq/governor_userspace.c: 56','&nbsp;


	
	
	
	<span><span>56:
sscanf(buf, "%lu", &amp;wanted);<br><br></span><u>Description
and Scenario:</u></span>
<span><br>Value
returned from a function is not checked for errors before being
used.<br>On success, the function returns the number of items in the
argument list successfully filled. <br>This count can match the
expected number of items or be less (even zero) in the case of a
matching failure.<br>In the case of an input failure before any data
could be successfully interpreted, EOF is returned. This should be
checked.</span>

<br>',7,'2013-08-16 16:14:39.872586','2013-08-16 16:14:39.872586','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(13,'@ /drivers/gpu/ion/ion_system_heap.c: 215','<span><span><br>Dereferencing
freed pointer "info" at line 215 of </span>
</span>
<span><br>
</span>
list_for_each_entry(info,
&amp;pages, list) { 

<span><br><br>216
free_buffer_page(sys_heap, buffer, info-&gt;page, info-&gt;order); 
</span>
<span><br>217
 kfree(info); 
</span>
<span><br><br>
</span>
<span>may
free "info" already freed in previous loop iterations, for
example when <i>&amp;info-&gt;list
!= &amp;pages</i>
condition is true earlier in the loop.</span>
<span><br><br>
</span>
The
team needs to check the pointer before kfree()ing it.

<br>',5,'2013-08-16 16:16:05.953803','2013-08-16 16:16:05.953803','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(14,'@ .../drivers/gpu/pvr/services4/srvkm/devices/sgx/sgxutils.c: 1447,1252,1787','There are 3 occurrences, the same by nature. Let''s understand and example on line 1447<br><br>Passing freed pointer "psCleanup-&gt;psResItem" in the following call results in use after free.<br><br>PVR_DPF((PVR_DBG_ERROR, "ResManFreeResByPtr: hResItem 0x%x", (unsigned int)psCleanup-&gt;psResItem));<br><br><br><br><br>Starting Scenario (initial freeing of resources):<br><br>Line 1443 calls <br>&nbsp;&nbsp;&nbsp; Error = ResManFreeResByPtr(psCleanup-&gt;psResItem, bForceCleanup); // from drivers/gpu/pvr/services4/srvkm/common/resman.c<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; This function in turn calls <br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Line 515: eError = FreeResourceByPtr(psResItem, IMG_TRUE, bForceCleanup); <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Which in turn calls linux memory de-allocator:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; OSFreeMem(PVRSRV_OS_PAGEABLE_HEAP,sizeof(RESMAN_ITEM), psItem, IMG_NULL); <br><br>Then back in sgxutils.c at line 1444 we see an evaluation. <br>1444: if(eError != PVRSRV_OK) <br><br>If evaluates to TRUE we fall through to Line 1447 dereferencing the pointer.&nbsp;&nbsp;&nbsp; <br><br>1447: PVR_DPF((PVR_DBG_ERROR,"ResManFreeResByPtr: hResItem 0x%x",(unsigned int)psCleanup-&gt;psResItem)); <br><br>This effectively passes an already freed psCleanup-&gt;psResItem to PVR_DPF debug print routine. <br><br>This may result in the very least in improper reporting of the pointer location and the worst case a format bug which may reference a null pointer.<br><br>',5,'2013-08-16 16:21:14.298054','2013-08-16 16:21:14.298054','L1','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(15,'@ .../drivers/iommu/exynos-iommu.c: 672','Given that&nbsp; line 633:<br><br>struct exynos_iommu_owner *owner = NULL<br><br>and&nbsp; assignment at line 640&nbsp; <br><br>owner = drvdata-&gt;master-&gt;archdata.iommu;<br><br>Below is where the code checks for "owner" pointer being valid after <br><br>642 if (owner)<br>643&nbsp;&nbsp;&nbsp; spin_lock(&amp;owner-&gt;lock);<br><br><br><br>However further in code we see dereference of that pointer which may be NULL if error has occurred in previous allocation (line 640)<br>672 ret = report_iommu_fault(drvdata-&gt;domain, <br>673&nbsp;&nbsp;&nbsp; owner-&gt;dev, addr, itype);<br><br><br>Always maintain the atomic pointer reference logic or explicitly check for NULL on the pointer. Alternatively, if check for null pointer is not necessary (line 642) please remove it.<br><br><br><br><br>',2,'2013-08-16 16:22:33.696429','2013-08-16 16:22:33.696429','L1','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(16,'@ .../drivers/media/video/exynos/gsc/gsc-capture.c: 1176','Pointer "crop" returned by "v4l2_subdev_get_try_crop(fh, pad)" is never used.<br><br>1175&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (which == V4L2_SUBDEV_FORMAT_TRY) {&nbsp;&nbsp; <br>1176&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; crop = v4l2_subdev_get_try_crop(fh, pad);<br><br><br><br>',8,'2013-08-16 16:24:01.565745','2013-08-16 16:24:01.565745','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(17,'@   .../drivers/media/video/exynos/tv/mixer_drv.c : 181,326','Scenario 1:<br>&nbsp;170 :&nbsp;&nbsp; if (pad)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; .... <br>logic follows&nbsp; on positive check <br>then, breaking out of the loop we see dereference outside of the “if” statement : <br><br>181:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sd = media_entity_to_v4l2_subdev(pad-&gt;entity); <br><br>This implies pad may be null, and this is not checked in atomic conditional statement: Time of check time of use violation.<br><br><br>Scenario 2:<br>&nbsp;315 :&nbsp;&nbsp;&nbsp;&nbsp; if (pad) // positive check<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ... <br>logic follows&nbsp; on positive check <br>then, breaking out of the loop we see dereference outside of the “if” statement : <br><br>326:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hdmi_sd = media_entity_to_v4l2_subdev(pad-&gt;entity);<br><br>This implies pad may be null, and this is not checked in atomic conditional statement: Time of check time of use violation.<br><br>Either the check against null is unnecessary, or there may be a null pointer dereference.<br>Pointer is checked against null but then dereferenced anyway <br><br>',2,'2013-08-16 16:26:46.020599','2013-08-16 16:26:46.020599','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(18,'@  .../drivers/mmc/host/dw_mmc.c: 2384','<span><span>Under certain conditions
in the loop variable alighned_buf defined at: <br>2376               
        u64 </span><b>aligned_buf</b><span>[16];<br><br>is
passed to memcpy unintialized at:<br>2384                       
memcpy(buf, </span><b>aligned_buf</b><span>,
len);<br><br>Other uses similar to 2384 on lines 2302, 2220<br><br>The
variable will contain an arbitrary value left from earlier
computations.<br>Use of an uninitialized variable </span>
</span>

<br>',9,'2013-08-16 16:28:31.960996','2013-08-16 16:29:37.029844','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(19,' @ .../drivers/mmc/host/dw_mmc.c: 1960,1994,1998,2007,2012,2022,2028,2040,2220,2302,2384','Comparing "data" pointer to null implies that "data" might be null.<br>1932&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data &amp;&amp;&nbsp; ... ) {<br><br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Non-atomic access to potentially null "data" by accessing “data”<br><br>Scenario 1:<br>1960&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (data-&gt;stop)<br><br>Scenario 2:<br>1994&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;error = -ETIMEDOUT;<br><br>Scenario 3:<br>1998&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;error = -EILSEQ;<br><br>Scenario 4:<br>2007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;bytes_xfered = 0;<br><br>Scenario 5:<br>2012&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;error = -EIO;<br><br>Scenario 6:<br>2022&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;error = -EIO;<br><br>Scenario 7:<br>2028&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;error = -EIO;<br><br>Scenario 8:<br>2040&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data-&gt;bytes_xfered = data-&gt;blocks * data-&gt;blksz;<br><br><br>Either the check against null is unnecessary, or there may be a null pointer dereference.<br>Pointer is checked against null but then dereferenced anyway.<br><br><br>',2,'2013-08-16 16:33:45.083096','2013-08-16 16:33:45.083096','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(20,'@ .../drivers/spi/spi-s3c64xx.c: 1234','<br>1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);<br><br>If the function returned a handle to an object, the handle may be lost.<br>Pointer returned from a function was never used <br><br><br><br>',8,'2013-08-16 16:35:05.945412','2013-08-16 16:35:05.945412','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(21,'@ ../drivers/usb/dwc3/exynos-drd-switch.c     193','193&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xhci = hcd_to_xhci(hcd);<br><br><br>If the function returned a handle to an object, the handle may be lost.<br>Pointer returned from a function was never used.<br><br><br>',8,'2013-08-16 16:35:50.354549','2013-08-16 16:35:50.354549','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(22,'@ .../drivers/usb/gadget/android.c : 1031','With uninitialized variable at:<br>1003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int err;<br><br>we can see that the below condition can be&nbsp; reached under certain conditions with the variable set to an arbitrary value left from earlier computations.<br><br><u>Use Scenario 1:</u><br>1031&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err) { <br>1032&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_err("%s: Failed to create function %s attributes", <br>1033&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __func__, f-&gt;name); <br>1034&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_out; <br>1035&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><u>Use Scenario 2:</u><br>1028&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ((attr = *attrs++) &amp;&amp; !err)<br><br>',9,'2013-08-16 16:38:20.015568','2013-08-16 16:38:20.015568','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(23,'@ .../drivers/usb/gadget/android.c: 1213','Value returned from a function is not checked for errors before being used<br><br>Use Scenario 1:<br>1213&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf(buff, "%d", &amp;enabled);<br><br>Use Scenario 2:<br>525&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sscanf(buf, "%d", &amp;value);<br><br>Should be modeled after the follwing pattern:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!sscanf(buf, "%d", &amp;enabled)) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return -EINVAL; <br><br><br>If the function returns an error value, the error value may be mistaken for a normal value.<br><br><br><br>',7,'2013-08-16 16:40:53.914315','2013-08-16 16:40:53.914315','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(24,'@  ../drivers/usb/gadget/composite.c: 180','Potentially missing break statement between cases in switch statement <br><br>Is this by design?<br><br><br>178&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case USB_ENDPOINT_XFER_ISOC:&nbsp; <br>179&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mult: bits 1:0 of bmAttributes */&nbsp; <br>180&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _ep-&gt;mult = comp_desc-&gt;bmAttributes &amp; 0x3;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>The above case falls through to this one :<br>181&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case USB_ENDPOINT_XFER_BULK:<br><br>Execution falls through to the next case statement or default; this might indicate a common typo.<br><br><br>',10,'2013-08-16 16:44:09.006511','2013-08-16 16:44:09.006511','L1','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(25,'@ .../drivers/video/fbmon.c: 709','There may be a null pointer dereference, or else the comparison against null is unnecessary.<br>All paths that lead to this null pointer comparison already dereference the pointer earlier<br><br>First - Dereference<br>702&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ver = edid[EDID_STRUCT_VERSION];<br><br>Then - Check:<br>709&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (edid == NULL || !edid_checksum(edid) ||<br><br><br><br>',3,'2013-08-16 16:46:25.893155','2013-08-16 16:46:25.893155','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(26,'@ .../drivers/video/s3c-fb.c: 2239','<br>Variable Declared:<br><br>2172&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct s3c_dma_buf_data old_dma_bufs[S3C_FB_MAX_WIN];<br><br>Under certain logic path&nbsp; passed to<br><br>2239&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s3c_fb_free_dma_buf(sfb, &amp;old_dma_bufs[i]);<br><br>The variable will contain an arbitrary value left from earlier computations.<br><br><br><br><br>',9,'2013-08-16 16:47:31.278676','2013-08-16 16:47:31.278676','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(27,'@ drivers/video/s5p_mipi_dsi.c : 1074','<br>dsim-&gt;dsim_config is referenced prior to being checked for NULL.<br><br>1073&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dsim-&gt;dsim_lcd_drv = dsim-&gt;dsim_config-&gt;dsim_ddi_pd; //&nbsp; Note: this is defined as pointer&nbsp; void *dsim_ddi_pd;<br><br><br><br>1075&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (dsim-&gt;dsim_config == NULL) {<br>1076&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(&amp;pdev-&gt;dev, "dsim_config is NULL.\n");<br>1077&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto err_dsim_config;<br>1078&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>Unless a dsim_ddi_pd is used&nbsp; to delete the dsim_config struct I don''t understand why the check for NULL. <br><br>To verify/fix either: <br>a) Check for NULL should be done before dereferencing it on line 1073 or removed,<br>b) There are threading issues between the two calls (1073 and 1075) that may invalidate the dsim_config. In which case those two should be made atomic calls with a lock.<br><br>',3,'2013-08-16 16:52:11.032385','2013-08-16 16:52:11.032385','L1','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(28,'@ ../sound/soc/soc-dapm.c: 2906, 2888','Dereferencing potentially null pointer "w". Non-atomic ( time of check, time of use) execution of reference&nbsp; Either the check against null is unnecessary, or there may be a null pointer dereference.<br><br><br><u>Scenario 1:</u><br>2900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w = snd_soc_dapm_new_control(dapm, &amp;template);<br><br>2901&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!w) { <br>2902&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(dapm-&gt;dev, "Failed to create %s widget\n", <br>2903&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dai-&gt;driver-&gt;capture.stream_name); <br>2904&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br><br>2906&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w-&gt;priv = dai; <br>2907&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dai-&gt;capture_widget = w;<br><br><br><u>Scenario 2:</u><br>2882&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w = snd_soc_dapm_new_control(dapm, &amp;template);<br><br>2883&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!w) { <br>2884&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_err(dapm-&gt;dev, "Failed to create %s widget\n", <br>2885&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dai-&gt;driver-&gt;playback.stream_name); <br>2886&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>2887&nbsp;&nbsp;&nbsp;&nbsp; <br>2888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w-&gt;priv = dai; <br>2889&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dai-&gt;playback_widget = w; <br>2890&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br>',2,'2013-08-16 16:53:31.670372','2013-08-16 16:53:31.670372','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(29,'@ .../sound/soc/soc-dapm.c: 1211','A null pointer dereference will occur on accessing <b>dapm-&gt;card</b><br><br>Under the condition on line <br>1165&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>cur_dapm</b> = NULL;<br><br>Logically failing thorugh to&nbsp; line where the null pointer is passed to function:<br><br>1211&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dapm_seq_run_coalesced(<b>cur_dapm</b>, &amp;pending);<br><br>where in that function&nbsp; it is referenced at:<br>1067&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct snd_soc_card *card =<b> dapm-&gt;card</b>; <br><br><br>',2,'2013-08-16 16:56:01.672417','2013-08-16 16:56:01.672417','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(30,'@ .../arch/arm/common/bL_switcher.c: 590','<i>sprintf(char *, char const *, ...) </i>will overrun its first argument "buff" which can accommodate 20 bytes. <br><br>Defined:<br><i>573&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char buff[20];</i><br><br>Invoked:<br><i>589&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</i><br><i>590&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count += sprintf(buff, "Not support operation mode\n");</i><br><br>The number of bytes written may be 28 bytes (length of the static string), including the terminating null.<br>This could cause an immediate crash or incorrect computations.<br><br><br>',12,'2013-08-16 17:07:20.003611','2013-08-28 19:10:24.993154','L2','Change sprintf to&nbsp; snprintf() call:<br><a rel="" target="" href="http://libslack.org/manpages/snprintf.3.html">http://libslack.org/manpages/snprintf.3.html</a><br><br><a rel="" target="" href="https://www.securecoding.cert.org/confluence/display/seccode/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator">https://www.securecoding.cert.org/confluence/display/seccode/STR31-C.+Guarantee+that+storage+for+str...</a><br><br><br>',NULL,NULL,1,10);
INSERT INTO "flaws" VALUES(31,'@ ../arch/arm/kernel/smp.c: 109','Call to function that can return fault without explicit checks on return condition:<br><br>109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait_for_completion_timeout(&amp;cpu_running,<br>110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msecs_to_jiffies(1000));<br><br><br>Correct check is modeled elsewhere in code:<br><br>183&nbsp;&nbsp;&nbsp;&nbsp; if(!wait_for_completion_timeout(&amp;cpu_died,msecs_to_jiffies(5000))){ <br>184&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_err("CPU%u:cpudidn''tdie\n",cpu); <br>185&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br>186&nbsp;&nbsp;&nbsp;&nbsp; }<br><br><br>',7,'2013-08-16 17:08:24.672528','2013-08-16 17:08:24.672528','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(32,'@ .../arch/arm/mach-exynos/common.c: 744','Defined unsigned int (always stores values over 0)<br>712 unsigned int ret;<br><br>Used:<br>742 ret=irq_set_affinity(combiner_data[combiner_nr].parent_irq, <br>743&nbsp;&nbsp;&nbsp;&nbsp; &amp;target_affinity);<br>744&nbsp;&nbsp;&nbsp;&nbsp; if(ret&gt;=0)<br><br>Unsigned compared against 0 .This greater-than-or-equal-to-zero comparison of an unsigned value is always true. <br><br>Return value may be lost (unaccounted&nbsp; for).<br><br><br>',13,'2013-08-16 17:11:27.233901','2013-08-16 17:11:27.233901','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(33,'@ .../arch/arm/mach-exynos/board-smdk5410-mmc.c: 85','Two cases exhibit a fallthrough without a break. Those cases look like they are mutually exclusive by what can be understood via logic. However we lack context -&nbsp; this may be OK and by design?<br>85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 8:<br>&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (gpio = EXYNOS5410_GPC3(0);<br>&nbsp;87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gpio &lt;= EXYNOS5410_GPC3(3); gpio++) {<br>&nbsp;88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));<br>&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);<br>&nbsp;90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV4);<br>&nbsp;91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp; <br>fallthrough: The above case falls through to this one.<br><br>92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 4:<br>&nbsp;93&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (gpio = EXYNOS5410_GPC0(3);<br>&nbsp;94&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gpio &lt;= EXYNOS5410_GPC0(6); gpio++) {<br>&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));<br>&nbsp;96&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);<br>&nbsp;97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s5p_gpio_set_drvstr(gpio, S5P_GPIO_DRVSTR_LV4);<br>&nbsp;98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br><br>',10,'2013-08-16 17:13:06.151565','2013-08-16 17:13:06.151565','L1','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(34,'@ .../arch/arm/mach-exynos/dev-sysmmu.c : 565','This code can never be reached because of a logical contradiction.<br><br>First "propmap" is declared with a NULL:<br><br>505 struct sysmmu_prop_map*propmap=NULL;<br><br>Further in code reliance on initial definition shows that&nbsp; condition "propmap" cannot be true.<br>564 if(propmap){ <br>565&nbsp;&nbsp;&nbsp;&nbsp; for(i=0;i&lt;npropmap;i++){ <br>566&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct sysmmu_platform_data*platdata; <br>567&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platdata=propmap[i].pdev-&gt;dev.platform_data; <br>568&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; platdata-&gt;prop=propmap[i].prop;<br>569&nbsp;&nbsp;&nbsp;&nbsp; } <br>570}<br><br>The indicated dead code may have performed some action; that action will never occur.<br><br>',14,'2013-08-16 17:14:22.496579','2013-08-16 17:14:22.496579','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(35,'@  .../arch/arm/mach-exynos/exynos-power-mode.c 146','146 device_create_file(exynos_power_mode_dev,&amp;dev_attr_cur_power_mode);<br><br>explicit checks for return value are not performed. However they are needed because called code can return errors.<br><br>For example device_create_file calls intdevice_create_file @ drivers/base/core.c which is designed to return faults:<br><br>530 intdevice_create_file(structdevice*dev, <br>531&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; conststructdevice_attribute*attr) <br>532{<br>533&nbsp;&nbsp;&nbsp;&nbsp; int error=0;<br>534&nbsp;&nbsp;&nbsp;&nbsp; if(dev)<br>535&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error=sysfs_create_file(&amp;dev-&gt;kobj,&amp;attr-&gt;attr); <br>536&nbsp;&nbsp;&nbsp;&nbsp; return error; <br>537}<br><br>Correct check would be something like:<br>error=device_create_file(...);<br>if(error) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br><br><br>',7,'2013-08-16 17:15:52.349094','2013-08-16 17:15:52.349094','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(36,'@ arch/arm/mach-exynos/setup-fimc-is.c : Multiple','The address of an array is never NULL, so the comparison will always evaluate the same way.<br>The code has features that do not directly introduce a weakness or vulnerability, but indicate that the product has not been carefully developed or maintained. <br><br>Defined ( in include/media/exynos_fimc_is.h )<br><br>313 *sensor_info[FIMC_IS_MAX_CAMIF_CLIENTS];<br>Used:<br>1793 if(sensor-&gt;sensor_power.cam_core)<br>1805 if(sensor-&gt;sensor_power.cam_io_myself)<br>1811 if(sensor-&gt;sensor_power.cam_io_peer)<br>1825 if(sensor-&gt;sensor_power.cam_af)<br>1850 if(sensor-&gt;sensor_power.cam_core)<br>1870 if(sensor-&gt;sensor_power.cam_io_myself)<br>1876 if(sensor-&gt;sensor_power.cam_io_peer)<br>2008 if(sensor-&gt;sensor_power.cam_io_peer)<br><br><br>',15,'2013-08-16 17:19:50.925432','2013-08-16 17:19:50.925432','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(37,'@ .../arch/arm/plat-samsung/devs.c: 1307','Assignment of a pointer npd:<br><br>1307 npd=s3c_set_platdata(pd,sizeof(struct samsung_pwm_platdata) … )<br><br>The called function&nbsp; s3c_set_platdata from arch/arm/plat-samsung/platformdata.c can return NULL but the npd pointer is not checked for that. Actually. the pointer itself&nbsp; is unused. Therefore the severity is lower at this point. However, either use the pointer&nbsp; and check for return or remove it from operation.<br><br>',7,'2013-08-16 17:21:11.132001','2013-08-16 17:22:09.781860','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(38,'@ .../arch/arm/plat-samsung/pm.c: 299','The following call does not check for return value:<br>299 cpu_suspend(0,pm_cpu_sleep);<br><br>Function int cpu_suspend(unsignedlongarg,int(*fn)(unsignedlong)) can return -EINVAL&nbsp;&nbsp; (value: 22)<br><br><br>',7,'2013-08-16 17:23:34.275651','2013-08-16 17:23:34.275651','L2','Correct would be to call similar to this:<br><br>ret= cpu_suspend(0,pm_cpu_sleep);<br>if(ret)<br>&nbsp; do_something<br><br>',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(39,'@ .../drivers/media/video/exynos/tv/hdmi_edid.c: 486, 487, 488','435 ret=fb_edid_add_monspecs(edid+i*EDID_BLOCK_SIZE,&amp;specs);<br><br>As can be seen &amp;specs is passed to a function fb_edid_add_monspecs(unsigned char *edid, struct fb_monspecs *specs)&nbsp; which is located in&nbsp; drivers/video/fbmon.c<br>&nbsp;<br>This function frees specs.audiodb @ drivers/video/fbmon.c: <br>1239&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(specs-&gt;audiodb);<br><br><br>Then further in code we see&nbsp; specs.audiodb&nbsp; passed to a function fb_destroy_audiodb(struct fb_audio *audiodb)<br>&nbsp;in drivers/video/fbmon.c&nbsp; where this element is freed again:<br><br>486 fb_destroy_audiodb(specs.audiodb);<br>&nbsp;&nbsp;&nbsp; which calls <br>&nbsp;&nbsp;&nbsp; 777&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(audiodb);<br><br>Other uses:<br><br>A)<br>Another member specs.videodb is incorrectly freed on line <br>487&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fb_destroy_videodb(specs.videodb);<br><br>which has already been freed in function fb_destroy_videodb:<br>782&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(videodb);<br><br>B)<br>Another member specs.vsdb is incorrectly freed:<br><br>488&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fb_destroy_vsdb(specs.vsdb);<br><br>which has already been freed in function fb_destroy_vsdb:<br>787&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kfree(vsdb);<br><br>Depending on the implementation of the deallocator function, the memory may by placed on the free list more than once.<br><br><br>',5,'2013-08-16 17:25:09.160627','2013-08-16 17:25:09.160627','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(40,'@ .../drivers/thermal/exynos_thermal.c: 339','Considering the following is defined: <br>116 #define GET_TRIP(zone) (zone - 2)<br><br><br>After checking the trip value in the following evaluation:<br>303&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (trip &lt; GET_TRIP(MONITOR_ZONE) || trip &gt; GET_TRIP(PANIC_ZONE))<br><br><br>trip value is between 0 and 2<br><br>However in switch on trip value the statements in the default case are never executed as case 0:1:2 are all present (all possible values).<br>323&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (trip) {<br>339&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:<br>340&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;<br><br><br>',10,'2013-08-16 17:26:18.224143','2013-08-16 17:26:18.224143','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(41,'@ .../drivers/thermal/exynos_thermal.c: 1125','Declared:<br>1108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long temp[EXYNOS_TMU_COUNT]<br><br>The array can be used with initialized values under certain conditions:<br><br>1125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len += snprintf(&amp;buf[len], THERMAL_NAME_LENGTH, "sensor%d : %ld\n", i, temp[i]);<br><br>The variable will contain an arbitrary value left from earlier computations. In this case - anything that is left in memory upon initialization.<br><br>',9,'2013-08-16 17:27:34.817665','2013-08-16 17:27:34.817665','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(42,'@ .../drivers/thermal/thermal_sys.c: 1231','The following call does not check for return value:<br><br>1231&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; device_create_file(&amp;tz-&gt;device,<br>1232&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;tz-&gt;trip_temp_attrs[indx].attr);<br><br>device_create_file can return error from system calls&nbsp; ( ENOMEM, ENOENT, etc.) so it should be checked upstream by the calling function. If the function returns an error value, the error value may be mistaken for a normal value.<br><br>',7,'2013-08-16 17:28:32.600254','2013-08-16 17:28:32.600254','L2','<br><br>Better way to address this:<br><br>ret=device_create_file(...);<br>&nbsp;&nbsp; if (ret == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp; do_domething;<br><br>',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(43,'@   .../drivers/usb/core/hub.c : 4125','The following call does not check for return value:<br>4152&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usb_autoresume_device(udev);<br><br>If the function returns an error value, the error value may be mistaken for a normal value.<br>In fact, the same construct is used in the same code differently where return code is checked indicating this may be important:<br><br>2720&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status = usb_autoresume_device(udev);<br>2721&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (status == 0) {<br>2722&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Let the drivers do their thing, then... */<br><br><br>',7,'2013-08-16 17:29:40.368025','2013-08-16 17:29:40.368025','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(44,'@ .../drivers/usb/host/xhci.c: 1751','Execution falls through to the next case statement or default; this might indicate a common typo or be used by design. <br><br><br>748&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case COMP_EBADSLT:<br>1749&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dev_warn(&amp;udev-&gt;dev, "WARN: slot not enabled for"<br>1750&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "evaluate context command.\n");<br><br>&nbsp;&nbsp;&nbsp; <br>fallthrough: The above case falls through to this one.<br>1751&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case COMP_CTX_STATE:<br><br>',10,'2013-08-16 17:30:27.202104','2013-08-16 17:30:27.202104','L1','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(45,'@ .../drivers/usb/host/xhci-hub.c: 1215','Execution falls through to the next case statement or default; this might indicate a common typo or be used by design. <br><br>1215&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case USB_PORT_FEAT_C_SUSPEND:<br>1216&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bus_state-&gt;port_c_suspend &amp;= ~(1 &lt;&lt; wIndex);<br><br>&nbsp;&nbsp;&nbsp; <br>fallthrough: The above case falls through to this one.<br>1217&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case USB_PORT_FEAT_C_RESET:<br><br><br>',10,'2013-08-16 17:31:20.075331','2013-08-16 17:31:20.075331','L1','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(46,'@ .../drivers/usb/host/xhci.c: 1291','Initial allocation of memory:<br><br>1199&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer = kzalloc(size * sizeof(struct xhci_td), mem_flags);<br>It is used here to assign values to another location but then it is never freed before the function exit:<br><br>1205&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; size; i++) {<br>1206&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; urb_priv-&gt;td[i] = buffer;<br>1207&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer++;<br>1208&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br><br>Under certain logic buffer goes out of scope when the function exits. The system resource will not be reclaimed and reused, reducing the future availability of the resource.<br><br><br>',1,'2013-08-16 17:32:07.416538','2013-08-16 17:32:07.416538','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(47,'@ ../drivers/usb/host/xhci-mem.c:  2484  ','Step 1: Comparing "xhci-&gt;dcbaa" to null implies that "xhci-&gt;dcbaa" might be set to null.<br>2324&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!xhci-&gt;dcbaa)<br><br><br>Step 2: However further in code we see a call to:<br>2484&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xhci_mem_cleanup(xhci);<br>└&nbsp;&nbsp;&nbsp; which calls <br>&nbsp;&nbsp;&nbsp; └&nbsp;&nbsp;&nbsp; 1771&nbsp;&nbsp;&nbsp; void xhci_mem_cleanup(struct xhci_hcd *xhci)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; which calls <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └&nbsp;&nbsp;&nbsp; 1798&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xhci_free_virt_device(xhci, i);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; which dereferences xhci-&gt;dcbaa <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; └&nbsp;&nbsp;&nbsp; 876&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xhci-&gt;dcbaa-&gt;dev_context_ptrs[slot_id] = 0;<br><br><br>Either the check against null is unnecessary, or there may be a null pointer dereference deep in the&nbsp; xhci_free_virt_device function backtraced to xhci_mem_cleanup call.<br><br><br><br><br>',2,'2013-08-16 17:33:53.062847','2013-08-16 17:33:53.062847','L2','Possibly check for xhci-&gt;dcbaa before passing it to xhci_mem_cleanup calls.<br>',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(48,'@ .../drivers/gud/MobiCoreKernelApi/connection.c: 173','<br>Then memory pointed to by skb goes out of scope without being&nbsp; freed when the function exits<br><br>Initial pointer assignment:<br><br>151 skb=nlmsg_new(NLMSG_SPACE(len),GFP_KERNEL);<br><br>If evaluation of the following condition&nbsp; (when ''ret'' is not set to anything from initial ''0'' )&nbsp; takes false branch :<br><br>170 if(!ret&amp;&amp;skb!=NULL)<br><br><br>The system resource will not be reclaimed and reused, reducing the future availability of the resource.<br><br><br><br>',1,'2013-08-16 17:35:02.586779','2013-08-16 17:35:02.586779','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(49,'@ ../packages/apps/Nfc/nci/jni/RouteDataSet.cpp: 326','&nbsp;


	
	
	
	<span><span>326&nbsp;&nbsp;&nbsp;&nbsp;chmod&nbsp;(filename.c_str&nbsp;(),&nbsp;S_IRUSR&nbsp;|&nbsp;S_IWUSR&nbsp;|&nbsp;S_IRGRP&nbsp;|&nbsp;S_IROTH);<br><br>The
function returns a value that indicates an error condition. If this
is not checked, the error condition may not be handled correctly.<br></span><br>
</span>

<br>',7,'2013-08-20 17:41:15.716550','2013-08-20 17:41:31.205239','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(50,'@ ../packages/apps/Nfc/nci/jni/NativeNfcManager.cpp: 603, 599, 593','<span>Resource
pointed to nat is not freed when goes out of scope
<br>&nbsp;<br>Defined:<br>538&nbsp;&nbsp;&nbsp;&nbsp;nfc_jni_native_data*&nbsp;nat&nbsp;=&nbsp;NULL;</span>
<span><br>Assigned:<br>&nbsp;545&nbsp;&nbsp;&nbsp;&nbsp;nat&nbsp;=&nbsp;(nfc_jni_native_data*)malloc(sizeof(struct&nbsp;nfc_jni_native_data));<br><br>Goes
out of scope at the end of function
static&nbsp;jboolean&nbsp;nfcManager_initNativeStruc&nbsp;(JNIEnv*&nbsp;e,&nbsp;jobject&nbsp;o)
in 3 places: <br><br><br>&nbsp;593 &nbsp; &nbsp; &nbsp; &nbsp;return
JNI_FALSE;<br>&nbsp;594 &nbsp; &nbsp;}<br><br>&nbsp;603&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;JNI_TRUE;
&nbsp;<br>&nbsp;604}<br><br><br>&nbsp;599&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;JNI_FALSE;
<br>&nbsp;600&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><br>No intermediate
operations freed the resource.<br>The system resource will not be
reclaimed and reused, reducing the future availability of the
resource.</span>

<br>',1,'2013-08-20 17:42:24.011170','2013-08-26 19:01:47.704994','L2','',NULL,NULL,1,10);
INSERT INTO "flaws" VALUES(51,'@  external/libnfc-nci/src/nfa/dm/nfa_dm_discover.c: 2043','<span>Value
returned from a function is not checked for errors before being
used<br><br>2043&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nfa_dm_disc_notify_activation&nbsp;(&amp;(p_data-&gt;nfc_discover));<br><br>If
the function returns an error value, the error value may be mistaken
for a normal value.<br><br>Example of proper checks in code:<br><br>2013
&nbsp; &nbsp; &nbsp; &nbsp;if (nfa_dm_disc_notify_activation
(&amp;(p_data-&gt;nfc_discover)) == NFA_STATUS_FAILED)<br>2014 &nbsp;
&nbsp; &nbsp; &nbsp;{</span>
			....



<br>',7,'2013-08-20 17:43:12.243907','2013-08-20 17:43:12.243907','L2','',NULL,NULL,2,NULL);
INSERT INTO "flaws" VALUES(52,'@ .../external/libnfc-nci/src/nfa/hci/nfa_hci_act.c	520, 359','<span>359&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((<b>p_pipe</b><span>&nbsp;=&nbsp;nfa_hciu_find_pipe_by_owner&nbsp;(nfa_hci_cb.app_in_use))&nbsp;==&nbsp;NULL)<br><br>520&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((</span><b>p_pipe</b><span>&nbsp;=&nbsp;nfa_hciu_find_pipe_on_gate&nbsp;(p_gate-&gt;gate_id))&nbsp;==&nbsp;NULL)<br>If
the function returned a handle to an object, the handle may be
lost.<br><br>Pointer returned from a function was never used
(</span><u><a rel="" target="" href="http://cwe.mitre.org/data/definitions/563.html">CWE-563</a></u><span>)<br></span><br><br>
</span>

<br>',8,'2013-08-20 17:43:58.673154','2013-08-20 17:43:58.673154','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(53,'@ ../external/libnfc-nci/src/nfc/tags/ce_t4t.c	334','<span><span>Pre-Requisites:
Consider the following defintiion in
libnfc-nci/src/nfc/include/tags_defs.h <br>341
#define&nbsp;T4T_RSP_CMD_CMPLTED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x9000<br><br><br>The
value of status_words is assigned the value of
T4T_RSP_CMD_CMPLTED:<br><br>267&nbsp;&nbsp;&nbsp;&nbsp;UINT16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;starting_offset,&nbsp;</span><b>status_words;</b><span><br>294&nbsp;&nbsp;&nbsp;&nbsp;</span><b>status_words</b><span>&nbsp;=&nbsp;T4T_RSP_CMD_CMPLTED;<br><br><br>&nbsp;
&nbsp; <br>Below the value of "status_words" </span><u>must</u><span>&nbsp;be
equal to T4T_RSP_CMD_CMPLTED because of earlier asignment. And
therefore must be TRUE<br>&nbsp; &nbsp; <br>&nbsp;330 &nbsp; &nbsp;if
(status_words == T4T_RSP_CMD_CMPLTED)<br>&nbsp;331 &nbsp; &nbsp;{<br>&nbsp;332
&nbsp; &nbsp; &nbsp; &nbsp;return TRUE;<br>&nbsp;333 &nbsp;
&nbsp;}<br><br>Hence, the code below is not
reached<br><br>&nbsp;334&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;FALSE;
&nbsp;<br>&nbsp;335}<br><br></span><br><br>
</span>

<br>',14,'2013-08-20 17:44:58.486922','2013-08-20 17:44:58.486922','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(54,' @ .../drivers/gpu/arm/mali400/mali/common/mali_broadcast.c	50','<span><span>Storage
is returned from allocation function
"_mali_osk_malloc(u32)"<br>Assigning to "bcast_unit"
= storage returned:<br><br>&nbsp;32 &nbsp; &nbsp; &nbsp;
&nbsp;</span><b>bcast_unit</b><span>&nbsp;=
_mali_osk_malloc(sizeof(struct mali_bcast_unit));<br><br>Then an
evaluation is perfromed on the following line (call to a function in
drivers/gpu/arm/mali400/mali/common/mali_hw_core.c )
<br>38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(_MALI_OSK_ERR_OK&nbsp;==&nbsp;mali_hw_core_create(</span><b>&amp;bcast_unit-</b>&gt;hw_core,&nbsp;resource,&nbsp;bcast_unit_reg_size))</span>
<span><span><br>The
mali_hw_core_create function itself does not free the storage
allocated to bcast_unit, and if false branch is taken when variable
"</span><b>bcast_unit</b><span>"
is going out of scope: <br><br>50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;<br>51}</span></span>

<br><br>&nbsp;


	
	
	
	This
leaks the storage it points to.&nbsp;
<span><span><br>The system
resource will not be reclaimed and reused, reducing the future
availability of the resource. <br>Leak of memory or pointers to
system resources (</span><u><a rel="" target="" href="http://cwe.mitre.org/data/definitions/404.html">CWE-404</a></u><span>)<br><br></span><br><br>
</span>

<br><br>',1,'2013-08-20 17:45:57.006402','2013-08-20 17:45:57.006402','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(55,'@ .../drivers/gpu/arm/mali400/mali/common/mali_kernel_core.c:	988','<span><span>Storage is
returned from allocation function "_mali_osk_notification_create(u32,
0)".<br>Assigning to "notification"
<br><br><br>&nbsp;979&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><b>notification</b><span>&nbsp;=&nbsp;_mali_osk_notification_create(args-&gt;type,&nbsp;0);<br><br>Then:
Resource "notification" is not freed or pointed-to when
passed to the following
function:<br><br>&nbsp;986&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_mali_osk_notification_queue_send(queue,&nbsp;</span><b>notification</b><span>);<br><br>&nbsp;Variable
"notification" going out of scope and &nbsp;leaks the
storage it points to:<br>988&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MALI_SUCCESS;&nbsp;/*&nbsp;all&nbsp;ok&nbsp;*/<br>989}<br><br>The
system resource will not be reclaimed and reused, reducing the future
availability of the resource. <br>Leak of memory or pointers to
system resources (</span><u><a rel="" target="" href="http://cwe.mitre.org/data/definitions/404.html">CWE-404</a></u><span>)<br></span><br><br>
</span>

<br>',1,'2013-08-20 17:46:56.432636','2013-08-20 17:46:56.432636','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(56,'@ .../drivers/gpu/arm/mali400/mali/platform/pegasus-m400/exynos4_pmm.c	602','&nbsp;


	
	
	
	<span>Line
602&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clk_set_parent(<b>mali_clock</b><span>,&nbsp;mali_parent_clock);<br>&nbsp;	Passing
null pointer "</span><b>mali_clock</b>"
to function "clk_set_parent(struct clk *, struct clk *)",
which dereferences it.</span>
<ul><ul><li><span>arch/arm/plat-samsung/clock.c
		in function int&nbsp;clk_set_parent(struct&nbsp;clk&nbsp;<b>*clk</b>,&nbsp;struct&nbsp;clk&nbsp;*parent)
		
		</span>
		</li><li><span>219
		&nbsp; &nbsp; &nbsp; &nbsp;if (<b>clk-</b>&gt;ops
		&amp;&amp; <b>clk</b>-&gt;ops-&gt;set_parent)
		{ 
		</span>
		</li><li>220
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
		&nbsp;trace_clock_set_parent(clk-&gt;name, parent-&gt;name); 
		
		</li><li>221
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret =
		(clk-&gt;ops-&gt;set_parent)(clk, parent); 
		
		</li><li>222
		&nbsp; &nbsp; &nbsp; &nbsp;} 
		
		</li><li>223 
		
	</li></ul></ul>
Either the check
against null is unnecessary, or there may be a null pointer
dereference.

<br>&nbsp;<span>Pointer is
checked against null but then dereferenced anyway (<u><a rel="" target="" href="http://cwe.mitre.org/data/definitions/476.html">CWE-476</a></u>)</span>

<br><br>',2,'2013-08-20 17:47:51.842033','2013-08-20 17:47:51.842033','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(57,'@ .../drivers/gpu/pvr/services4/srvkm/env/linux/pvr_sync.c: 284','Analysing the function “PVRSyncIOCTLImport” that contains the call to copy_from_user at line 366<br><br>366 if (copy_from_user(&amp;sData, (void __user *)ulArg, sizeof(sData)))<br>367&nbsp;&nbsp;&nbsp; goto err_out;<br><br>and verifying the type of data used to transfer data from user to kernel space: PVR_SYNC_IMPORT_IOCTL_DATA (as defined at line 356) and defined in "pvr_sync_user.h" file that is included in "pvr_sync.h" file;<br><br>struct PVR_SYNC_CREATE_IOCTL_DATA<br>{<br>&nbsp;&nbsp;&nbsp; IMG_HANDLE hKernelServices;<br>&nbsp;&nbsp;&nbsp; IMG_HANDLE hSyncInfo;<br>&nbsp;&nbsp;&nbsp; IMG_CHAR name[32];<br>&nbsp;&nbsp;&nbsp; int iFenceFD;<br>};<br><br><br>The type IMG_HANDLE is defined within the header file /gpu/pvr/include4/img_types.h:<br><br>124 typedef IMG_PVOID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IMG_HANDLE;<br><br>again, the type IMG_PVOID is defined as a pointer to void:<br><br>103 typedef void&nbsp; IMG_VOID, *IMG_PVOID;<br><br>This means that "hKernelServices" and "hSyncInfo" are both pointers of type void. This condition creates the opportunity to pass a NULL pointer from userspace and generate a NULL pointer dereference vulnerability.<br><br>Continuing the analysis, looking into the function below, at line 284 is called the function "PVRSRVLookupHandle" using "sData.hKernelServices" parameters that, as showed above, it is a pointer and can potentially be NULL.<br><br><br>284&nbsp;&nbsp;&nbsp; eError = PVRSRVLookupHandle(KERNEL_HANDLE_BASE,<br>285&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (IMG_PVOID *)&amp;psPerProc,<br>286&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sData.hKernelServices,<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; PVRSRV_HANDLE_TYPE_PERPROC_DATA);<br><br>The function "PVRSRVLookupHandle" is defined in file: drivers/gpu/pvr/services4/srvkm/include/handle.h (that is not part of the project scope). The parameter "sData.hKernelServices" is passed as second parameter to "*ppvData" that is a pointer to IMG_PVOID. As this is potentially NULL and at line 350 the pointer is dereferenced (*ppvData = hHandle), this can cause a NULL pointer dereference, so it is vulnerable L2.<br><br><br>345 PVRSRV_ERROR PVRSRVLookupHandle(PVRSRV_HANDLE_BASE *psBase, IMG_PVOID *ppvData, IMG_HANDLE hHandle, PVRSRV_HANDLE_TYPE eType)<br>346 {<br>347 &nbsp;&nbsp;&nbsp; PVR_UNREFERENCED_PARAMETER(psBase);<br>348&nbsp;&nbsp;&nbsp; PVR_UNREFERENCED_PARAMETER(eType);<br>349<br>350&nbsp;&nbsp;&nbsp; *ppvData = hHandle;<br>351&nbsp;&nbsp;&nbsp; return PVRSRV_OK;<br>352 }<br><br>',2,'2013-08-26 15:24:57.279708','2013-08-26 15:24:57.279708','L2','',NULL,NULL,1,NULL);
INSERT INTO "flaws" VALUES(58,'@ .../drivers/base/core.c: 1833','if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;shutdown) { <br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dev_dbg(dev, "shutdown\n");<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dev-&gt;bus-&gt;shutdown(dev);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } else if (dev-&gt;driver &amp;&amp; dev-&gt;driver-&gt;shutdown) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dev_dbg(dev, "shutdown\n");<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; dev-&gt;driver-&gt;shutdown(dev);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; put_device(dev);<br><br><br>',16,'2013-08-26 15:30:34.533922','2013-08-26 15:30:34.533922','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(59,'@  .../drivers/base/core.c:  1788','&nbsp;&nbsp;&nbsp; case DPM_ORDER_DEV_LAST:<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; device_pm_move_last(dev);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp;&nbsp; }<br><br><br>',17,'2013-08-26 15:32:17.227745','2013-08-26 19:11:51.702082','L2','',NULL,NULL,3,100);
INSERT INTO "flaws" VALUES(60,' @ drivers/base/power/domain.c: 190','Scenario A:<br>function "pm_genpd_poweron" is indirectly recursive through "__pm_genpd_poweron", which is unsafe.<br><br>Function __pm_genpd_poweron is called by pm_genpd_poweron:<br><br>245: &nbsp;&nbsp;&nbsp; ret = __pm_genpd_poweron(genpd);<br><br>But it itself calls the parent:<br>149: int __pm_genpd_poweron(struct generic_pm_domain *genpd) <br>the parent calls the function pm_genpd_poweron again: <br>190: &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ret = pm_genpd_poweron(link-&gt;master); <br><br>Scenario B:<br>function "pm_genpd_sync_poweroff" is directly recursive, which is unsafe.<br><br>744: &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pm_genpd_sync_poweroff(link-&gt;master);<br><br>static void pm_genpd_sync_poweroff(struct generic_pm_domain *genpd)<br>{<br>&nbsp;&nbsp;&nbsp; struct gpd_link *link;<br><br>&nbsp;&nbsp;&nbsp; if (genpd-&gt;status == GPD_STATE_POWER_OFF)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br><br>&nbsp;&nbsp;&nbsp; if (genpd-&gt;suspended_count != genpd-&gt;device_count<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;|| atomic_read(&amp;genpd-&gt;sd_count) &gt; 0)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br><br>&nbsp;&nbsp;&nbsp; if (genpd-&gt;power_off)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; genpd-&gt;power_off(genpd);<br><br>&nbsp;&nbsp;&nbsp; genpd-&gt;status = GPD_STATE_POWER_OFF;<br><br>&nbsp;&nbsp;&nbsp; list_for_each_entry(link, &amp;genpd-&gt;slave_links, slave_node) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; genpd_sd_counter_dec(link-&gt;master);<br>744&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pm_genpd_sync_poweroff(link-&gt;master);<br>&nbsp;&nbsp;&nbsp; }<br>}<br><br><br>',18,'2013-08-26 15:33:32.108033','2013-08-26 15:34:23.367656','L1','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(61,'@ drivers/cpufreq/cpufreq_ondemand.c      1382','else if (policy-&gt;min &gt; this_dbs_info-&gt;cur_policy-&gt;cur)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; __cpufreq_driver_target(this_dbs_info-&gt;cur_policy,<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; policy-&gt;min, CPUFREQ_RELATION_L);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mutex_unlock(&amp;this_dbs_info-&gt;timer_mutex);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; break;<br><br><br>',16,'2013-08-26 15:35:08.746087','2013-08-26 15:35:08.746087','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(62,'@ drivers/cpufreq/cpufreq_ondemand.c:  1382 ','',17,'2013-08-26 15:35:37.725639','2013-08-26 19:13:58.879747','L2','',NULL,NULL,3,50);
INSERT INTO "flaws" VALUES(63,'@ drivers/cpufreq/exynos-ikcs-cpufreq.c: 644','',17,'2013-08-26 15:36:13.602091','2013-08-26 19:12:14.215579','L2','',NULL,NULL,3,100);
INSERT INTO "flaws" VALUES(64,'@  drivers/cpufreq/exynos-ikcs-cpufreq.c: 438 ','438: asm volatile ("mrc\tp15, 0, %0, c0, c0, 5\n" : "=r"(core));<br><br><br>',19,'2013-08-26 15:37:34.339759','2013-08-26 15:48:31.734668','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(65,'@ drivers/cpufreq/exynos5410-cpufreq.c: 766','<span><span><br>740
	if (old_index &gt; new_index) {<br><br>766 	} else if (old_index &lt;
new_index) {<br><br><br>falls though and what about old_index ==
new_index condition?<br></span><br><br>
</span>

<br>',16,'2013-08-26 15:38:38.160898','2013-08-26 15:38:38.160898','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(66,'@ drivers/dma/pl330.c: 699, 776, 865, 2535','697&nbsp;&nbsp;&nbsp; if (cond == SINGLE)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buf[0] |= (0 &lt;&lt; 1) | (1 &lt;&lt; 0);<br>&nbsp;&nbsp;&nbsp; else if (cond == BURST)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; buf[0] |= (1 &lt;&lt; 1) | (1 &lt;&lt; 0);<br><br><br>',16,'2013-08-26 15:39:23.873864','2013-08-26 15:39:23.873864','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(67,'@ drivers/gpu/ion/exynos/exynos_ion.c 57, 98','object includes more than 2 levels of indirection (3 levels).<br><br>57: &nbsp;&nbsp;&nbsp; phys_addr_t ***lv2ppimbufs)<br><br>98: &nbsp;phys_addr_t ***ppim_phys_bufs = NULL;<br><br>',20,'2013-08-26 15:40:35.655485','2013-08-26 15:40:35.655485','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(68,'@ drivers/gpu/ion/exynos/exynos_ion.c: 85, 427 ','59 &nbsp;&nbsp;&nbsp; if (idx &lt; MAX_LV0IMBUFS) {<br><br>69 &nbsp; } else if (idx &lt; MAX_IMBUFS) {<br><br><br>&nbsp; (idx == MAX_IMBUFS) condition is not accounted for.<br><br><br>425 &nbsp;&nbsp;&nbsp; else if (flags &amp; ION_EXYNOS_G2D_WFD_MASK)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; type = "g2d_wfd";<br><br>',16,'2013-08-26 15:41:47.330462','2013-08-26 15:41:47.330462','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(69,'@  drivers/gpu/ion/exynos/ion.c: 712','if (client &lt; entry)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p = &amp;(*p)-&gt;rb_left;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if (client &gt; entry)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; p = &amp;(*p)-&gt;rb_right;<br><br>',16,'2013-08-26 15:42:26.494485','2013-08-26 15:42:26.494485','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(70,'@ drivers/gpu/ion/ion_system_heap.c: 313','if (offset &gt;= sg_dma_len(sg)) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; offset -= sg_dma_len(sg);<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; continue;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; } else if (offset) {<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; page += offset / PAGE_SIZE;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; len = sg_dma_len(sg) - offset;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; offset = 0;<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br><br>',16,'2013-08-26 15:42:56.367841','2013-08-26 15:42:56.367841','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(71,'@ drivers/gpu/ion/ion_page_pool.c: 112','&nbsp;&nbsp;&nbsp; if (pool-&gt;high_count)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; page = ion_page_pool_remove(pool, true);<br>&nbsp;&nbsp;&nbsp; else if (pool-&gt;low_count)<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; page = ion_page_pool_remove(pool, false);<br><br><br>',16,'2013-08-26 15:43:30.326198','2013-08-26 15:43:30.326198','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(72,'@ sound/soc/soc-dapm.c: 689','689: static int is_connected_output_ep(struct snd_soc_dapm_widget *widget)<br><br>747: &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; con += is_connected_output_ep(path-&gt;sink);<br><br><br><br>760: static int is_connected_input_ep(struct snd_soc_dapm_widget *widget)<br><br>830: &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; con += is_connected_input_ep(path-&gt;source);<br><br><br>',18,'2013-08-26 15:44:19.577518','2013-08-26 15:44:19.577518','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(73,'@ drivers/iommu/exynos-iommu.c: 993','<br>993 static struct device * __init __sysmmu_init_master(<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; struct device *sysmmu, struct device *dev) {<br><br>1012 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pret = __sysmmu_init_master(sysmmu, master-&gt;archdata.iommu);<br><br><br>',18,'2013-08-26 15:45:09.255564','2013-08-26 15:45:09.255564','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(74,'@ drivers/usb/core/hub.c: 1667, 1500','<u>Scenario A:</u><br>1500 static void recursively_mark_NOTATTACHED(struct usb_device *udev)<br><br>1506 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; recursively_mark_NOTATTACHED(udev-&gt;children[i]);<br><br><u>Scenario B: </u><br>1667 void usb_disconnect(struct usb_device **pdev)<br><br>1685 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; usb_disconnect(&amp;udev-&gt;children[i]);<br><br><br>',18,'2013-08-26 15:45:55.391235','2013-08-26 15:45:55.391235','L2','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(75,'@ arch/arm/mach-exynos/reserve-mem.c: 84','&nbsp;function "__cma_secure_reserve" is indirectly recursive through "exynos_cma_region_reserve", which is unsafe.<br><br>84: static void __init __cma_secure_reserve(phys_addr_t paddr_laast,<br>&nbsp;&nbsp;&nbsp; struct cma_region *regions_secure, struct cma_region *regions_adjacent)<br><br>calls exynos_cma_region_reserve<br><br>198 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; exynos_cma_region_reserve(regions_adjacent, NULL, NULL, NULL);<br><br>The function exynos_cma_region_reserve calls &nbsp; __cma_secure_reserve back at <br><br>328 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; __cma_secure_reserve(<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; paddr_last, regions_secure, regions_adjacent);<br><br>',18,'2013-08-26 15:46:30.045250','2013-08-26 15:46:30.045250','L1','',NULL,NULL,3,NULL);
INSERT INTO "flaws" VALUES(76,'@  arch/arm/common/bL_entry.c: 248','248 : &nbsp;&nbsp;&nbsp; asm ("mrc\tp15, 0, %0, c0, c0, 5" : "=r" (mpidr));<br><br>',19,'2013-08-26 15:47:04.581324','2013-08-26 15:47:04.581324','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(77,'@  arch/arm/common/bL_switcher.c: 82','82: &nbsp;&nbsp;&nbsp; asm volatile ("mrc\tp15, 0, %0, c0, c0, 5" : "=r" (id));<br><br>',19,'2013-08-26 15:47:34.284642','2013-08-26 15:47:34.284642','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(78,'@  arch/arm/kernel/smp.c: 224','224: &nbsp;&nbsp;&nbsp; __asm__("mov&nbsp;&nbsp;&nbsp; sp, %0\n"<br>&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; fp, #0\n"<br>&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp; secondary_start_kernel"<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; :<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : "r" (task_stack_page(current) + THREAD_SIZE - 8));<br><br>',19,'2013-08-26 15:48:07.848995','2013-08-26 15:48:07.848995','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(79,'@   arch/arm/mach-exynos/debug_exynos5410.c (Multiple)','24-<br>--<br>74:&nbsp;&nbsp;&nbsp; asm volatile("mcr p14, 0, %0, c1, c0, 4" : : "r" (UNLOCK_MAGIC));<br>75-}<br>--<br>80:&nbsp;&nbsp;&nbsp; asm volatile("mcr p14, 0, %0, c1, c0, 4" : : "r" (0x1));<br>81-}<br>--<br>85:&nbsp;&nbsp;&nbsp; asm volatile("mcr p15, 0, r0, c7, c5, 4" : : );<br>86-}<br>--<br>92:&nbsp;&nbsp;&nbsp; asm volatile(<br>93-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mrc p14, 0, %0, c0, c0, 5\n"<br>--<br>120:&nbsp;&nbsp;&nbsp; asm volatile(<br>121-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mrc p14, 0, %0, c0, c0, 6\n"<br>--<br>161:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm volatile(<br>162-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c0, c0, 5\n"<br>--<br>189:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm volatile(<br>190-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c0, c0, 6\n"<br>--<br>211:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm volatile(<br>212-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c0, c0, 5\n"<br>--<br>239:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm volatile(<br>240-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c0, c0, 6\n"<br>--<br>269:&nbsp;&nbsp;&nbsp; asm volatile(<br>270-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mrc p14, 0, %0, c0, c2, 2\n"<br>--<br>283:&nbsp;&nbsp;&nbsp; asm volatile(<br>284-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mrc p14, 0, %0, c7, c9, 6"<br>--<br>289:&nbsp;&nbsp;&nbsp; asm volatile(<br>290-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mrc p14, 0, %0, c0, c3, 2\n"<br>--<br>309:&nbsp;&nbsp;&nbsp; asm volatile(<br>310-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c0, c2, 2\n"<br>--<br>325:&nbsp;&nbsp;&nbsp; asm volatile(<br>326-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c7, c8, 6"<br>--<br>331:&nbsp;&nbsp;&nbsp; asm volatile(<br>332-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; "mcr p14, 0, %0, c0, c3, 2\n"<br>--<br>399:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm volatile("mrc p14, 0, %0, c0, c2, 2"<br>400-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : "=r"(reg_DSCR));<br>401:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm volatile("mcr p14, 0, %0, c0, c2, 2"<br>402-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; : : "r"(reg_DSCR | (1 &lt;&lt; 14)));<br><br>',19,'2013-08-26 15:49:08.588032','2013-08-26 15:49:08.588032','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(80,'@ arch/arm/mach-exynos/hotplug.c (Multiple)','--<br>33:&nbsp;&nbsp;&nbsp; asm volatile(<br>34-&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp; mcr&nbsp;&nbsp;&nbsp; p15, 0, %1, c7, c5, 0\n"<br>--<br>54:&nbsp;&nbsp;&nbsp; asm volatile(<br>55-&nbsp;&nbsp;&nbsp; " &nbsp; &nbsp; &nbsp; mrc &nbsp; &nbsp; p15, 0, %0, c1, c0, 0\n"<br>--<br>64:&nbsp;&nbsp;&nbsp; asm volatile(<br>65-&nbsp;&nbsp;&nbsp; /*<br>--<br>86:&nbsp;&nbsp;&nbsp; asm volatile(<br>87-&nbsp;&nbsp;&nbsp; "mrc&nbsp;&nbsp;&nbsp; p15, 0, %0, c1, c0, 0\n"<br>--<br>138:&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; asm(".word&nbsp;&nbsp;&nbsp; 0xe320f003\n"<br>139-&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;:<br><br><br>',19,'2013-08-26 15:49:57.894382','2013-08-26 15:49:57.894382','L2','',NULL,NULL,5,NULL);
INSERT INTO "flaws" VALUES(81,'@    external/libnfc-nci/src/nfa/dm/nfa_dm_act.c: 1807','1805 default:<br>1806 return "unknown revt";<br>1807 &nbsp;&nbsp;&nbsp; break; <br><br><br>',14,'2013-08-26 15:50:43.204762','2013-08-26 15:50:43.204762','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(82,'@  external/libnfc-nci/src/nfa/hci/nfa_hci_act.c: 1214','1212 &nbsp; &nbsp; &nbsp; &nbsp; nfa_hciu_send_open_pipe_cmd (NFA_HCI_ADMIN_PIPE);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return;<br>1214 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; break;<br><br><br>',14,'2013-08-26 15:51:10.255865','2013-08-26 15:51:10.255865','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(83,'@ packages/apps/Nfc/nci/jni/RouteDataSet.cpp: 561','&nbsp; &nbsp; switch (selection)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; case DefaultRouteDatabase:<br>&nbsp; &nbsp; &nbsp; &nbsp; return &amp;mDefaultRouteDatabase;<br>&nbsp; &nbsp; case SecElemRouteDatabase:<br>#ifdef NFC_SEC_PROP /* Multi routing table */<br>&nbsp; &nbsp; &nbsp; &nbsp; return &amp;mSecElemRouteDatabase[selected_sec_route_db];<br>#else<br>&nbsp; &nbsp; &nbsp; &nbsp; return &amp;mSecElemRouteDatabase;<br>#endif<br>&nbsp; &nbsp; }<br>561 &nbsp; &nbsp;return NULL;<br><br>',14,'2013-08-26 15:51:39.236092','2013-08-26 15:51:39.236092','L2','',NULL,NULL,4,NULL);
INSERT INTO "flaws" VALUES(84,'drivers/gpu/arm/mali400/mali/common/mali_gp_scheduler.c: 184, 416, 530 ','146<br>&nbsp;&nbsp;&nbsp; job = _MALI_OSK_LIST_ENTRY(job_queue.next, struct mali_gp_job, list);<br>&nbsp;&nbsp;&nbsp; _mali_osk_list_del(&amp;job-&gt;list);<br><br><br>Defined in: drivers/gpu/arm/mali400/mali/common/mali_osk.h as:<br><br>508: #define _MALI_OSK_CONTAINER_OF(ptr, type, member) \`<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;((type *)( ((char *)ptr) - offsetof(type,member) ))<br><br>530: #define _MALI_OSK_LIST_ENTRY(ptr, type, member) \<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _MALI_OSK_CONTAINER_OF(ptr, type, member)<br><br><br>',21,'2013-08-26 15:53:49.611011','2013-08-26 19:57:53.981056','L2','',NULL,NULL,5,100);
CREATE TABLE classifications (id INTEGER PRIMARY KEY, title varchar(255), overview text, created_at datetime, updated_at datetime, "guidance" text, "reference" text, "affects" text);
INSERT INTO "classifications" VALUES(1,'Resource Leak','The software does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory. <br><br>Memory leaks have two common and sometimes overlapping causes:               <ul><li>Error conditions and other exceptional circumstances</li><li>Confusion over which part of the program is responsible for freeing							the memory</li></ul>Most memory leaks result in general software reliability problems, but							if an attacker can intentionally trigger a memory leak, the attacker							might be able to launch a denial of service attack (by crashing or							hanging the program) or take advantage of other unexpected program							behavior resulting from a low memory condition.<br><br><br>Small memory leaks can cause problems for processes running for long periods of time without restarting.<br>Severe memory leaks can cause a process to crash. A denial-of-service attack can occur if user input or<br>data from the network triggers a memory leak.<br><br>File descriptor or socket leaks can lead to crashes, denial of service, and the inability to open more files<br>or sockets. The operating system limits how many file descriptors and sockets a process can own. After<br>the limit is reached, the process must close some of the resources'' open handles before allocating more. If<br>the process has leaked these handles, there is no way to reclaim these resources until the process terminates.<br><br>Many memory leaks are on error paths where an error condition is encountered and memory is leaked<br>accidentally. <br><br><br><br>','2013-08-16 15:09:34.829247','2013-08-28 15:49:11.939481','To address resource leaks in your program, ensure that memory is deallocated on all paths, including error paths. <br><br>Some of these cases can be eliminated by having a single exit label in the function that every error exit goes to with a goto statement. This exit label can free resources as necessary.<br><br>A common technique for avoiding memory leaks is to use arenas that remember all memory allocated on<br>the arena until a single freeing point frees it all. When appropriate, arena allocators have significant speed<br>and correctness advantages.<br><br><br><br><br>','<a rel="" target="" href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=437">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=437</a><br><a rel="" target="" href="http://cwe.mitre.org/data/definitions/404.html">http://cwe.mitre.org/data/definitions/404.html</a><br><a rel="" target="" href="http://cwe.mitre.org/data/definitions/401.html">http://cwe.mitre.org/data/definitions/401.html</a><br><br><br>','@ &lt;some other location&gt;<br><br>');
INSERT INTO "classifications" VALUES(2,'NULL pointer dereference (after check)','This class addresses instances where a pointer is checked against NULL and then<br>later dereferenced.<br><br>Dereferencing a NULL pointer leads to undefined behavior, which is usually a program crash.  In very rare circumstances and environments, code execution is							possible.<br><br>Use cases:<br><br>• Checking against NULL and then dereferencing on a path on which it was NULL.<br>• Assigning NULL and then taking a path on which the value has not changed.<br><br>NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions. <br><br><br><br><br>','2013-08-16 15:22:10.216511','2013-08-28 19:01:55.446398','Use atomic NULL checks where execution of logic relies on immediately checked NULL values. Do not rely on previous NULL checks if the value of the checked resource may be modified. <br><br>&nbsp;<br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/476.html">http://cwe.mitre.org/data/definitions/476.html</a><br><br>','');
INSERT INTO "classifications" VALUES(3,'Dereference before NULL check','A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit. <br><br><br>Since dereferencing a NULL pointer will cause a process to crash, checking against NULL before<br>dereferencing is very important. This class describes instances where a pointer is dereferenced then<br>subsequently checked against NULL. <br>','2013-08-16 15:30:29.356720','2013-08-28 17:39:36.282654','The dereference can be safe if the programmer knows it could not<br>be null. If this is the case, then checking against NULL is unnecessary and should be removed as it indicates<br>that the pointer could be NULL. As a second possibility, the pointer might be NULL, and it can be fixed<br>by moving the NULL check before the dereference.<br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/476.html">http://cwe.mitre.org/data/definitions/476.html</a><br><a rel="" target="" href="https://www.securecoding.cert.org/confluence/display/seccode/EXP34-C.+Do+not+dereference+null+pointers">https://www.securecoding.cert.org/confluence/display/seccode/EXP34-C.+Do+not+dereference+null+pointe...</a><br><br><br>','');
INSERT INTO "classifications" VALUES(4,'Questionnable Sizeof() usage','This class covers isolated occurrences of sizeof operators that are technically legal in C/C++, yet are often erroneous. <br>This applies to:<br><br>• a function parameter that has a pointer type.<br>•<i> this</i> in C++, which is an implicit pointer-typed function parameter.<br>• the address of an object.<br>• a pointer arithmetic expression.<br><br><br>Additionally combinations of pointers and sizeof expressions that appear to be mismatched are covered by this class. For example,&nbsp; when a pointer and sizeof expression occur together, the sizeof expression is usually the size of memory that the pointer points to.<br><br>Incorrect size values can lead to a variety of issues, such as insufficient or excessive allocation, buffer<br>overruns, partial initialization or copying, and logic inconsistencies.<br><br><br><br><br>','2013-08-16 15:35:12.366365','2013-08-28 18:07:39.917706','Fixing these defects depends on what you intended the code to do. If the sizeof is genuinely incorrect,<br>you can often solve these issues by removing a level of indirection from the operand of sizeof, or by<br>adjusting the placement of parentheses.<br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/467.html">http://cwe.mitre.org/data/definitions/467.html</a><br><br>','');
INSERT INTO "classifications" VALUES(5,'Use after free()','This class addresses&nbsp; instances of freed memory use. Specifically, it references many types of double frees and freed pointer dereferences.<br>You cannot safely use freed memory. Double free defects occur when <i>free() </i>is called more than once with the same memory address argument. Double freeing a pointer can result in memory free list corruption and crashes. Dereferencing a freed pointer is dangerous because the pointer''s value might have been changed to a non-pointer value or a pointer to an arbitrary location.<br><br>In multi-threaded programs, double frees are especially dangerous because one thread could allocate another''s freed memory, resulting in very difficult to track race-conditions.<br><br>','2013-08-16 15:43:51.249639','2013-08-28 18:18:10.980910','Identify all variables and data stores that receive information from							external sources, and apply input validation to make sure that they are							only initialized to expected values.. <br>When freeing pointers, be sure to set them to NULL once they are							freed. However, the utilization of multiple or complex data structures							may lower the usefulness of this strategy. <br>Check the results of all functions that return a value and verify that							the value is non-null before acting upon it. <br>Explicitly initialize all your variables and other data stores, either							during declaration or just before the first usage.<br><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/416.html">http://cwe.mitre.org/data/definitions/416.html</a><br><br>','');
INSERT INTO "classifications" VALUES(7,'Unchecked return from important call','This class discusses many instances of inconsistencies in how function return values are handled. For example, it references the case where the code neglects to handle an error code returned from a system call.<br><br>Ignoring returned function error codes and assuming that an operation was successful can cause incorrect program behavior, and in some cases system crashes. <br><span><br>Two common programmer assumptions are "this function call can never fail" and "it doesn''t matter if this function call fails". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the software is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges. </span> <br><br><br>','2013-08-16 15:57:27.990169','2013-08-28 18:39:41.385998','<span><span>Check the results of all functions that return a value and verify that							the value is expected<i></i><div>                  <span>Checking the return value of the function will typically be sufficient, however beware of race conditions (<a rel="" target="" href="http://cwe.mitre.org/data/definitions/362.html">CWE-362</a>) in a concurrent environment. </span>               </div></span>            Ensure that you account for all possible return values from the							function. When designing a function, make sure you return a value or throw an							exception in case of an error.</span><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/252.html">http://cwe.mitre.org/data/definitions/252.html</a><br><br>','');
INSERT INTO "classifications" VALUES(8,'Unused Pointer','This category covers many instances of pointers assigned values from function calls but never used. For example, it can find places where a typo or cut-and-paste error means that the wrong variable is being accessed.<br><br>It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug. At the very least if the variable''s value is assigned but never used, making it a dead store. <br><br><br>','2013-08-16 16:11:17.256202','2013-08-28 18:42:45.249473','Remove unused variables from the code.<br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/563.html">http://cwe.mitre.org/data/definitions/563.html</a><br><br>','');
INSERT INTO "classifications" VALUES(9,'Uninitialized variable','This category covers&nbsp; instances of variables that are used without being initialized. For example stack variables do not have set values unless initialized. <br><br>They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. Also, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. <br><br> Using uninitialized variables can result in unpredictable behavior, crashes, and security holes.The presence of an uninitialized variable can sometimes indicate a typographic error in the code. <br><br><br><br><br><br><br><br><br>','2013-08-16 16:27:56.863367','2013-08-28 18:48:42.160819','<span>Identify and reduce attack surface by assigning all variables to an initial value. <span><br>Most compilers will complain about the use of uninitialized variables							if warnings are turned on. </span>Run or compile the software in a mode that reports undeclared							or unknown variables. This may indicate the presence of a typographic							error in the variable''s name.             </span><br><br><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/457.html">http://cwe.mitre.org/data/definitions/457.html</a><br><br>','');
INSERT INTO "classifications" VALUES(10,'Logical Control Flow Issues','The flaws in this class point to locations where the program omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition. <br><br>This class specifically addresses logicl flaws that may be a result of incorrect logical "fall though".<br>','2013-08-16 16:43:26.414788','2013-08-28 18:58:35.848482','Omission of a break statement might be intentional, in order to							support fallthrough. Semantic understanding of expected program behavior is							required to interpret whether the code is correct. Omitting a break statement so that one may fall through is often							indistinguishable from an error, and therefore should be avoided. If you							need to use fall-through capabilities, make sure that you have clearly							documented this within the switch statement, and ensure that you have							examined all the logical possibilities.<br><br><br><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/484.html">http://cwe.mitre.org/data/definitions/484.html</a><br><br><br><br>','');
INSERT INTO "classifications" VALUES(12,'Buffer Overrun','This class address possible buffer overflows due to incorrect size arguments being passed to buffer manipulation functions.<br>These incorrect arguments, when passed to functions such as strncpy() or memcpy(), or sprintf() can cause memory corruption, security defects, or program crashes.<br><br><br>','2013-08-16 17:06:25.597798','2013-08-28 19:11:40.306144','Consider adhering to the following rules when allocating and managing							an application''s memory:<ul><li>Double check that your buffer is as large as you specify.</li><li>When using functions that accept a number of bytes to copy, such								as strncpy(), be aware that if the destination buffer size is equal								to the source buffer size, it may not NULL-terminate the								string.</li><li>Check buffer boundaries if accessing the buffer in a loop and make								sure you are not in danger of writing past the allocated								space.</li><li>If necessary, truncate all input strings to a reasonable length								before passing them to the copy and concatenation functions.</li></ul><br>Use a vetted library or framework that does not allow this weakness to							occur or provides constructs that make this weakness easier to							avoid.<br><br><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/120.html">http://cwe.mitre.org/data/definitions/120.html</a><br><br>','');
INSERT INTO "classifications" VALUES(13,'Incorrect Type Conversion','A signed-to-unsigned conversion error takes place when a signed primitive is used as an unsigned value, usually as a size variable. <br><div> It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program.  </div><br>In this example the variable amount can hold a negative value when						it is returned. Because the function is declared to return an unsigned int,						amount will be implicitly converted to unsigned.<br>','2013-08-16 17:09:04.624332','2013-08-28 21:52:01.752766','<br>The value of an expression of integer type shall not be implicitly converted to a different type if:<br><ul><li>it is not a conversion to a wider type of the same signedness, or</li><li>the expression is complex, or</li><li>the expression is not constant and is a function argument, or</li><li>the expression is not constant and is a return expression</li></ul><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/195.html">http://cwe.mitre.org/data/definitions/195.html</a><br><div><div><br></div></div><br><br><br>','');
INSERT INTO "classifications" VALUES(14,'Unreachable Code','This class covers instances of code that can never be reached due to branches whose <br>condition will always evaluate exactly the same each time. The software contains dead code, which can never be executed. <br>Typically, the presence of dead code indicates that a logic error has occurred as a result of changes to a program or the program''s environment. <br><br><br><br><br>','2013-08-16 17:13:52.754235','2013-08-28 19:45:35.131630','Dead code is usually optimized out of a program during compilation. However, to improve readability and ensure that logic errors are resolved, dead code should be identified, understood, and eliminated.<br><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/561.html">http://cwe.mitre.org/data/definitions/561.html</a><br><a rel="" target="" href="https://www.securecoding.cert.org/confluence/display/seccode/MSC07-C.+Detect+and+remove+dead+code">https://www.securecoding.cert.org/confluence/display/seccode/MSC07-C.+Detect+and+remove+dead+code</a><br><br><br>','');
INSERT INTO "classifications" VALUES(15,'Code Quality Best Practice','This class describes features that do not directly introduce a weakness or vulnerability,<br>but indicate that the product has not been carefully developed or maintained. <br>','2013-08-16 17:18:05.910375','2013-08-28 19:47:16.693014','','','');
INSERT INTO "classifications" VALUES(16,'Else If not followed by Else','<span><span>Whenever&nbsp;an&nbsp;if&nbsp;statement&nbsp;is&nbsp;followed&nbsp;by&nbsp;one&nbsp;or&nbsp;more&nbsp;else&nbsp;if&nbsp;statements;&nbsp;the&nbsp;final&nbsp;<br>else&nbsp;if&nbsp;shall&nbsp;be&nbsp;followed&nbsp;by&nbsp;an&nbsp;else&nbsp;statement.&nbsp;In&nbsp;the&nbsp;case&nbsp;of&nbsp;a&nbsp;simple&nbsp;if&nbsp;statement&nbsp;then&nbsp;the&nbsp;else&nbsp;<br>statement&nbsp;need&nbsp;not&nbsp;be&nbsp;included.<br>The&nbsp;requirement&nbsp;for&nbsp;a&nbsp;final&nbsp;else&nbsp;statement&nbsp;is&nbsp;</span><u>defensive&nbsp;programming</u>.</span><br>','2013-08-26 15:29:25.782664','2013-08-28 19:47:45.827798','<span>&nbsp;The&nbsp;else&nbsp;statement&nbsp;shall either&nbsp;take&nbsp;appropriate&nbsp;action&nbsp;or&nbsp;contain&nbsp;a&nbsp;suitable&nbsp;comment&nbsp;as&nbsp;to&nbsp;why&nbsp;no&nbsp;action&nbsp;is&nbsp;taken.&nbsp;This&nbsp;is&nbsp;<br>consistent&nbsp;with&nbsp;the&nbsp;requirement&nbsp;to&nbsp;have&nbsp;a&nbsp;final&nbsp;default&nbsp;clause&nbsp;in&nbsp;a&nbsp;switch&nbsp;statement</span><br>','','');
INSERT INTO "classifications" VALUES(17,'Missing Default in switch','The code does not have a default case in a switch statement, which might lead to complex logical errors and resultant weaknesses. <br>','2013-08-26 15:31:56.689535','2013-08-28 19:48:54.646202','The&nbsp;requirement&nbsp;for&nbsp;a&nbsp;final&nbsp;default&nbsp;clause&nbsp;is&nbsp;defensive&nbsp;programming.&nbsp;This&nbsp;clause&nbsp;shall&nbsp;either&nbsp;take <br>appropriate&nbsp;action&nbsp;or&nbsp;contain&nbsp;a&nbsp;suitable&nbsp;comment&nbsp;as&nbsp;to&nbsp;why&nbsp;no&nbsp;action&nbsp;is&nbsp;taken.<br><br>','<a rel="" target="" href="http://cwe.mitre.org/data/definitions/478.html">http://cwe.mitre.org/data/definitions/478.html</a><br><br>','');
INSERT INTO "classifications" VALUES(18,'Function is (in-)directly recursive','<br>Recursive&nbsp;function&nbsp;calls&nbsp;cannot&nbsp;be&nbsp;used&nbsp;in&nbsp;safety related&nbsp;systems.&nbsp;Recursion&nbsp;carries&nbsp;with&nbsp;it&nbsp;the&nbsp;danger&nbsp;of&nbsp;exceeding&nbsp;available&nbsp;stack&nbsp;space,&nbsp;which&nbsp;can&nbsp;be&nbsp;a&nbsp;serious&nbsp;error. <br>Unless&nbsp;recursion&nbsp;is&nbsp;very&nbsp;tightly&nbsp;controlled,&nbsp;it&nbsp;is&nbsp;not&nbsp;possible&nbsp;to&nbsp;determine&nbsp;before&nbsp;execution&nbsp;what&nbsp;the&nbsp;worst-case&nbsp;stack&nbsp;usage&nbsp;could&nbsp;be.<br><br><br><br>','2013-08-26 15:33:12.721800','2013-08-28 19:52:40.565569','This is a note towards best practices and does not currently contribute to a verifiable flaw.<br>','','');
INSERT INTO "classifications" VALUES(19,'Assembly Code Isolation','<br>Where assembly language instructions are required it is recommended that they be encapsulated <br>and isolated in either (a) assembler functions, (b) C functions or (c) macros.<br>For reasons of efficiency it is sometimes necessary to embed simple assembly language instructions <br>in-line, for example to enable and disable interrupts. If it is necessary to do this for any reason, <br>then it is recommended that it be achieved by using macros.<br><br>Note that the use of in-line assembly language is an extension to standard C.<br><br><br>','2013-08-26 15:37:01.390614','2013-08-28 19:53:30.761384','Define ASM macros where possible.<br><br><i>&nbsp; #define NOP asm(" &nbsp; NOP")</i><br><br>','','');
INSERT INTO "classifications" VALUES(20,'Multiple levels of indirection','Use&nbsp;of&nbsp;more&nbsp;than&nbsp;2&nbsp;levels&nbsp;of&nbsp;indirection&nbsp;can&nbsp;seriously&nbsp;impair&nbsp;the&nbsp;ability&nbsp;to&nbsp;understand&nbsp;the&nbsp;behaviour&nbsp;of&nbsp;the&nbsp;code, <br>and&nbsp;should&nbsp;therefore&nbsp;be&nbsp;avoided.<br><br><br>','2013-08-26 15:40:02.936791','2013-08-26 15:40:02.936791','',NULL,'');
INSERT INTO "classifications" VALUES(21,'Offsetoff Macro','Use&nbsp;of&nbsp;this&nbsp;macro&nbsp;can&nbsp;lead&nbsp;to&nbsp;undefned&nbsp;behaviour&nbsp;when&nbsp;the&nbsp;types&nbsp;of&nbsp;the&nbsp;operands&nbsp;are&nbsp;incompatible <br>or&nbsp;when&nbsp;bit&nbsp;felds&nbsp;are&nbsp;used.<br><br><br>','2013-08-26 15:52:46.513632','2013-08-26 15:54:09.741829','The macro ""offsetof"", in library &lt;stddef.h&gt;, shall not be used. <br><br>',NULL,'/drivers/gpu/arm/mali400/mali/common/mali_group.c 762 1085 1642 253 497 635 651 &nbsp; <br>/drivers/gpu/arm/mali400/mali/common/mali_memory.c 1276 1287 274 1109 1198 1225 &nbsp; <br>/drivers/gpu/arm/mali400/mali/common/mali_pp_scheduler.c 195 252 291 339 676 1150 1184 1221 1226 1307 1325 &nbsp; <br>/drivers/gpu/arm/mali400/mali/common/mali_user_settings_db.c 25 &nbsp; <br>/drivers/gpu/arm/mali400/mali/linux/mali_osk_wq.c 115 &nbsp; <br>/drivers/gpu/arm/mali400/ump/common/ump_kernel_api.c 263 &nbsp; <br>/drivers/gpu/arm/mali400/ump/common/ump_kernel_common.c 180 200 &nbsp; <br><br>');
CREATE TABLE priorities (id INTEGER PRIMARY KEY, prioritynumber integer, priorityname varchar(255));
INSERT INTO "priorities" VALUES(1,1,'High');
INSERT INTO "priorities" VALUES(2,2,'Medium');
INSERT INTO "priorities" VALUES(3,3,'Low');
INSERT INTO "priorities" VALUES(4,4,'Info');
INSERT INTO "priorities" VALUES(5,5,'Best Practice');
CREATE TABLE "states" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "statename" varchar(255));
INSERT INTO "states" VALUES(1,'L1');
INSERT INTO "states" VALUES(2,'L2');
INSERT INTO "states" VALUES(3,'L3');
INSERT INTO "states" VALUES(4,'In progress');
DELETE FROM sqlite_sequence;
INSERT INTO "sqlite_sequence" VALUES('states',4);
CREATE UNIQUE INDEX "unique_schema_migrations" ON "schema_migrations" ("version");
COMMIT;
